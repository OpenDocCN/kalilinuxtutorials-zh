# PSTF2:被动安全工具指纹框架

> 原文：<https://kalilinuxtutorials.com/pstf2/>

[![Pstf2 : Passive Security Tools Fingerprinting Framework](img//ce893e9ff5d4c0dd66970ad50e75c4e8.png "Pstf2 : Passive Security Tools Fingerprinting Framework")](https://1.bp.blogspot.com/-e6QG4bCAkLE/YPqYmMm_cwI/AAAAAAAAKLQ/gQVZBtn-rjELxmhiTi6Fg0qx6Lrn31uYACLcBGAsYHQ/s616/fingerprint.png)

**PSTF2** 是一个被动安全工具指纹识别框架。

你曾经想要一个简单，容易和隐形旁路多类安全产品？pstf^2(发音为 pstf-square)是一个 HTTP 服务器的实现，能够进行被动浏览器指纹识别——它可能正是您正在寻找的东西。

当攻击者试图通过互联网传递有效载荷时，他们需要克服能够扫描传入链接的多种工具。一旦 pstf2 以被动方式检测到电子邮件过滤器、扫描引擎甚至通过 URL 提交到沙盒，所有这些都可以被绕过。

一旦检测到，该工具允许区分安全服务和潜在受害者，并提供恶意或良性响应。

关于这项研究的细节可以在这篇博文中找到:[https://blogs . akamai . com/sitr/2020/12/avoiding-link-scanning-security-services-with-passive-fingerprinting . html](https://blogs.akamai.com/sitr/2020/12/evading-link-scanning-security-services-with-passive-fingerprinting.html)

**利用被动指纹规避链接扫描安全服务**

**执行摘要**

链接扫描器是多种安全产品中的关键组件，包括电子邮件安全套件、建议直接检查可疑链接的网站等。在幕后，这些服务使用 web 客户端获取链接的内容。根据定义，这是一个机器人，也就是我们常说的“好机器人”这项研究讨论了威胁参与者应用传统策略对付“坏机器人”以逃避链接扫描器检测的场景。我们的重点放在对安全工具透明的被动技术上，这种技术允许攻击者干净而容易地绕过。

这项研究中使用的工具将在 BlackHat Europe 2020 期间推出，并将作为 GitHub 上的开源项目发布。

**什么是链接扫描仪？**

恶意软件作者通常通过以下方式向新的受害者传播他们的非法商品:

*   利用远程代码执行漏洞。如今，持有未知的远程代码执行链被认为是罕见的。
*   发送恶意文件的附件或链接，使用社交工程引诱受害者运行该文件。

涉及直接发送有效载荷的攻击可以通过反病毒软件或沙箱来解决，今天不做讨论。我们研究的服务旨在解决第二个场景带来的挑战——检查可疑链接。这些产品通过主动探测链接并应用一系列具有明确结论的测试来保护我们，允许或阻止对链接的访问。

最常见的嵌入链接扫描器的产品是那些扫描收到的电子邮件。如今，它甚至是小型企业的必备工具，可以作为 Office 365 和 G-Suite 订阅的一个组成部分或作为一个独立产品提供服务。当收到带有链接的电子邮件时，扫描程序通常会向有问题的资源发送 HTTP GET 请求，并将扫描响应，就像它是电子邮件附带的二进制文件一样。

请注意，虽然自动扫描带有链接的电子邮件是这种策略最常见的用途，但它远不是唯一的用途。有些服务会独立于链接内容扫描链接。再比如沙盒产品，允许通过 URL 提交。

**什么是被动指纹识别**

在街上遇到某人时，你可以通过两种不同的方式了解他或她的情况——你可以问一个问题，也可以观察和倾听他们的活动。后一种方法类似于被动指纹识别，当我们不执行任何动作，只是观察对象的行为。在我们的上下文中，这个对象不是一个人，而是一个向我们发送 web 资源请求的 web 客户端。

我们将被动 web 客户端指纹定义为在任何级别(从物理层到应用层)测量传入请求的不同属性和特征，只检查常规网络事务中可观察到的特征。关键特征是执行被动指纹识别的服务器在理想情况下无法与常规服务器区分开来。相比之下，主动 web 客户端指纹识别通常涉及在客户端运行代码，并且有自己的优点和缺点。

**利用被动指纹规避**

大约一年前，我们有了一个灵光乍现的时刻

*   链接扫描仪是多种产品中的关键组件，是良好的深度防御现代安全态势不可分割的一部分。
*   获取链接内容的一个关键组件是 web 客户端，产品无法分析它们看不到的内容。
*   从客户端系统的角度来看，被动指纹实际上是无法区分的。

有可能被动地对安全工具进行指纹识别吗？如果是这样的话，我们能否在为恶意内容提供潜在受害者的同时，为其提供一个错误的良性反应？

简单的回答是——是的。

由于多种因素的影响，每个 web 客户端的行为略有不同:物理和网络基础设施、操作系统、网络堆栈、软件约束以及开发人员选择的实际实现。

我们在这项研究中的目标是证明，通过被动收集上述任何因素留下的线索，我们可以区分使用真实浏览器的真实人类和安全供应商使用的自动化软件。

在 Akamai，我们已经成功识别“坏”机器人多年，所以我们能够在现实世界中证明我们的假设并不奇怪。

**在实践中检测链接扫描器**

我们进行了以下实验:

*   设置一个模拟潜在威胁的服务器。这个服务器是从零开始构建的，只实现了众所周知的被动指纹策略。
*   选择了检查链接的流行安全服务。
*   从安全工具触发对服务器的请求。

例如，为了测试一个电子邮件安全产品，我们向一个我们预先设置的受该产品保护的帐户发送了一封邮件。内容包括我们专用服务器上的一个网站链接。因为我们的服务器是为这个任务设置的，所以可以安全地假设任何传入的流量都是链接扫描活动的结果。对于任何被检查的服务，我们用不同的 URL 重复这个过程，保证实验之间没有交叉污染。下面列出了我们在实验中观察到的一些错误和特征。请注意，我们在这里提供的所有信息都是在几个月前向相关供应商披露的，并且大多数供应商已经修复了我们检测到的问题。尽管如此，由于并非所有人都这样做了，并且由于我们的目标不是羞辱而是提高整体安全状态，我们不指名道姓，也不提供任何供应商的明确指纹。

同样值得一提的是，所有被测试的产品都显示出至少一个特征。这意味着被动指纹识别是一种非常有效的策略，可能会允许攻击者破解任何相关产品。

**过时的浏览器版本**

几年前，供应商意识到他们需要包含一个伪造的 HTTP 用户代理头，因为一些威胁参与者已经根据这个头(或缺少这个头)过滤了传入的请求，如前一篇博文中所述。

可悲的是，在软件开发中，按预期运行的代码经常被忽略。几年前引入的欺骗报头今天仍在使用。虽然许多浏览器使用的 Chrome 版本已经有几年的历史了，但记录保持者是一个使用 Internet Explorer 6(！idspnonenote)的客户端。！！)用户代理头。Internet Explorer 于 2001 年 8 月 27 日发布，自 2016 年 1 月 12 日起不再支持。

另一类受此问题困扰的产品是沙盒。创建一个工作沙盒映像是非常棘手的，更新通常是禁用的。因此，这种类型的机器是非常静态的。根据我们的检查，似乎一些供应商使用浏览器自动化从可疑链接下载内容，在他们自己的虚拟机中生活。这意味着，不能定期更新浏览器版本将导致这种粗糙的工程解决方案成为״fingerprintable״的一个工件。

**硬编码的引用头**

在大多数情况下，当您单击网页上的链接时，链接的目标会知道您来自哪里，因为这些数据显示在 HTTP Referer 标头中。有些厂商为了模拟真实的浏览器，会恶搞这个头。假设恶意服务器被设置在 www.malicious.server.com，那么假报头被设置为 www.google.com/search?q=malicious.server.com,，这是特定的，以至于它不可能是真实的。此外，在某些情况下，此标题会丢失，例如，当用户在 Outlook 的电子邮件桌面客户端环境中单击链接时。如果攻击者知道潜在的受害者使用 Outlook，他或她就知道任何包含 Referer 标头的请求都是安全工具。

**通过报头披露**

另一个有问题的 HTTP 头是 Via，在某些(错误的)配置下，它公开了作为分析基础设施的一部分使用的代理的实际名称。像 X-Forwarded-For 这样的代理典型的其他头也可能泄漏信息，但是在我们检查的产品中没有出现。

**DNS PTR 记录**

“普通”DNS 记录，也称为 A 记录，允许客户端将 URL 解析为 IP。PTR 记录正好相反，允许客户端执行通常所说的[反向 DNS 查找](https://en.wikipedia.org/wiki/Reverse_DNS_lookup)，即获取与 IP 相关的 URL。虽然不是强制性的，但 PTR 记录在某些情况下是有用的，例如在反垃圾邮件机制的上下文中验证 IP 解析为特定的域。

奇怪的是，我们检查的一些服务有这样的记录，经常指向服务本身的主页。这意味着，如果您看到来自 IP 的传入请求并执行反向查询，您将看到它解析为 scanning.product.vendorName.com 形式的页面，这是对攻击者避免提供任何恶意内容的强烈提示。

这里，威胁参与者也已经实现了类似的方法，用 GetHostByAddr API 包装反向查询:

**披露为**

自治系统(通常缩写为或 ASN)是将 IP 地址范围与网络运营商联系起来的实体。我们已经观察到了两个可能的问题，它们是由检查客户端的 IP 身份引起的。第一种情况是大型安全供应商运营自己的 AS。将 IP 与 AS 相关联的记录是公开的，因此攻击者可以检查传入请求的起始 AS 并做出相应的响应。

第二个可能的问题是与云服务相关的知识产权，如亚马逊的 AWS 或谷歌和微软的同等服务。安全服务经常被迫使用这些服务来以可伸缩的方式分析大量的请求，这需要大量的资源。然而，使用与这些提供商相关联的 IP 对于不是真实用户的客户来说是一个强烈的暗示，因为绝大多数潜在的受害者并不操作云机器或者使用这样的服务作为互联网的网关。通过正确使用代理，至少可以在一定程度上缓解这个问题。

值得注意的是，在野外也观察到了类似的行为，直接按 IP 范围列入黑名单:

**异国 MTU**

最大传输单位(MTU)定义了在单个网络层事务中可以传输的数据包大小的上限。值的分布范围很小，与不同类型的链路层实现紧密相关。例如，以太网通常意味着值为 1500，而 DSL 是 1492。奇怪的是，一些主机服务提供商拥有独特的价值，这些价值在其他地方是不存在的，并且可以很容易地被用作检测机制。

**TCP 特性和用户代理相关性**

Windows、Linux 和 Mac 实现 TCP 栈的方式不同。与缓冲窗口大小一起设置的标志和选项只是允许我们创建 TCP 级指纹的一些属性。这产生了一个非常有效的策略–首先，通过 TCP 参数检测操作系统风格，然后检查用户代理标头和简化的操作系统，例如:

*Mozilla/5.0(麦金塔；英特尔 Mac OS X 10 _ 15 _ 7)apple WebKit/537.36(KHTML，像壁虎)Chrome/86 . 0 . 4240 . 198 Safari/537.36*

如果 TCP 隐含的值和报头之间有矛盾，很可能我们看到的是来自扫描仪的流量。这是一个非常常见的问题，因为许多供应商选择基于 Linux 的虚拟机，这在历史上更容易且更便宜地扩展。

我们想推荐 Michal Zalewski 的名为 [p0f](https://lcamtuf.coredump.cx/p0f3/) 的出色工具，该工具开箱即用，能够高度可靠地对特定 TCP 组合进行被动指纹识别，并拥有上述奇特 MTU 值的广泛存储库。

**好转**

因为上述攻击的许多部分已经在野外发生，我们必须做得更好。

你是蓝队队员还是领队？意识到你的工具的局限性，理解让你的用户处于危险中的场景，并且试着理解你是否有不同的缓解策略。例如，考虑通过在端点执行分析来阻止恶意内容，而不是通过不同的客户端。其他高度先进的工具不依赖于任何客户端，在 URL 本身上运行最先进的机器学习(ML)模型。Akamai 的企业威胁保护器(ETP)产品就是一个很好的例子。

您是链接扫描组件产品的供应商吗？了解自己的指纹，尽量减少。一些改进是微不足道的，而另一些是昂贵的，几乎是不可能的。首先，进行没有外部成本的更改，例如设置一个正确合理的用户代理或删除多余的头。持续维护最新的用户代理有点麻烦，但即使每隔几个月修改一次也足以避开攻击者的雷达。相比之下，一些修复是复杂和昂贵的，例如更换基于 Linux 的 VM 基础设施和使用 HTTP 代理每天发送无数的请求。

另一个考虑因素应该是对手收集这些指标的难度。例如，测量和分析传入请求的 MTU 和 TCP 属性需要专门的软件，如 p0f，而用户代理的阻止可以通过编辑记录良好的配置文件来实现，如 Apache 的״htacess״.考虑这样一种情况，攻击者对受损网站的访问受到限制——他或她可能能够像״htaccess״一样添加或编辑文件，但运行像 p0f 这样的新进程则是另一回事。即使攻击者可以在特定条件下运行它，这个过程也非常嘈杂，很可能会引起不必要的注意。

**框架**

作为研究的一部分，我们开发了一套工具，用于处理传入请求的特性和发送自定义响应。我们将其命名为 pstf^2——被动安全工具指纹识别框架。它包括一个定制的 Python HTTP 服务器，与一个 p0f 实例一起运行，并被设计为能够拦截所有上述潜在指纹。它区分潜在的受害者和安全部门，并作出相应的反应。当检测到“受害者”时，发送 EICAR 字符串作为响应；否则，客户端将被重定向到里克阿斯特利音乐视频。

该框架可在以下网址公开获取:

[https://github.com/G4lB1t/pstf2](https://github.com/G4lB1t/pstf2)

作为存储库的一部分，我们还发布了一个友好的 docker 映像，它简化了设置框架的过程。

如前所述，我们故意不公布任何安全产品的具体指纹。这不是疏忽；我们更愿意将此作为“读者的练习”。

**后记**

在这项研究中，我们描述了如何采取已知的策略，并将其重新应用于安全产品。我们知道的事实是，我们今天讨论的一些策略已经被威胁分子使用。我们不知道还有多少其他的在使用中？没有进一步的研究，我们永远不会知道。我们希望这份出版物能提高人们对许多安全产品中这一空白的认识。我们认为分享我们在机器人检测方面的专业知识是为了每个人的更大利益。

它是如何工作的？

真正的问题是——链接扫描器是如何工作的？检查恶意链接是一种涉及 web 客户端发送 HTTP GET 请求的操作。每个供应商使用不同的内部实现-大多数试图在某种程度上模拟真实的用户交互。pstf^2 是一个简单的基于 python 的 HTTP 服务器，它应用众所周知的 bot 检测策略来确定传入的请求是否来自自动化的安全工具。服务器的运营商可以定制响应，例如，如果检测到扫描仪，重定向到谷歌，否则发送恶意内容。

以下是作为 pstf^2:的一部分实施的主要策略

**应用层**

**过时的用户代理**

安全工具试图伪装成合法的客户端，模拟真实的浏览器，然而，通常情况并非如此。常见的情况是，对于十年前的浏览器版本，使用伪造的用户代理头的工具没有得到正确的维护。pstf^2 允许你为你认为真正的非过时版本设置一个最小的阈值。

**一般 HTTP 异常**

该工具能够检测多种类型的奇怪实现。BlackHat 讲座中介绍的几个例子是:

*   留下一个 **`via`** `:`头，它揭示了用于沙箱的虚拟主机的性质。
*   `**referer:**`表示链接是从谷歌到达的头，例如`**referer: google.com/search?**` **`q=specific.site.com`。**在我们测试的场景中，这毫无意义，因为该产品扫描电子邮件，当有人点击电子邮件(不是从网络界面)时，这个标题就不存在了。

**链路、网络和传输层**

**关联**

多个 TCP 参数可能意味着特定的操作系统版本或特定的风格。一些客户端欺骗用户代理头，但是运行在不同于他们声明的操作系统之上。

**MTU 值**

托管在特定云提供商网络上的客户端的 MTU 不同于 1500 字节的标准值。

**ASN**

在某些情况下，请求是从与特定安全供应商明确关联的 ASN 发出的。在其他情况下，请求的来源是一个云托管提供商，虽然不涉及特定的供应商，但也不太可能是一个典型的用户。

**DNS PTR 记录**

在极少数情况下，客户的 IP 地址有一个 PTR 记录，将它与安全供应商的 URL 相关联。

**设置 PSTF2**

**使用 Docker**

假设您已经安装了 Docker，事情就这么简单:

**坞站-合成**

**手动部署**

如果您希望避免 Docker，请遵循以下步骤。

**满足 Python 需求**

运行:

**pip 安装要求. txt**

这将安装任何所需的外部 Python 模块。

**获取 p0f**

在部署 pstf^2 之前，下载并安装 p0f。目前可从以下网址获得:

https://lcamtuf.coredump.cx/p0f3/

现在，正确配置 lib/servers/server_config.yml 以指向正确的路径，即:

**p0f_config:
#最起码改一下你的用户名，记得两个路径都要改
p0f _ bin _ path:'/Users/$ your _ user _ name/$ more _ folders/web _ FP/p0f-3.09 b/p0f '
p0f _ FP _ path:'/Users/$ your _ user _ name/$ more _ folders/web _ FP/p0f-3.09 b/p0f . FP '
iface:' lo0 '
p0f**

还要验证`**iface**`是运行 Python HTTP 服务器的同一个接口。在上面的例子中，它是环回接口。

**奔跑的 pstf^2**

满足要求后，运行:

**python driver.py**

您可以使用以下任何标志:

**–P0F _ BIN _ PATH P0F _ BIN _ PATH
–P0F _ FP _ PATH P0F _ FP _ PATH
–P0F _ IFACE P0F _ IFACE**

所有这些都用于调整与 p0f 相关的参数:二进制文件本身、指纹文件和我们使用的默认为`**eth0**`的接口。

您应该会看到类似如下的输出:

**2020-04-15 17:37:06896–PST F2 _ logger–INFO–Starting p0f…
2020-04-15 17:37:06896–PST F2 _ logger–INFO–Running 命令:
/Users/gbit ensk/work/web _ FP/p0f-3.09 b/p0f-I lo0-s/tmp/p0f _ socket-f/Users/gbit ensk/work
2020-04-15 17:37:06898–PST F2 _ logger–INFO–启动 HTTP 服务器…
2020-04-15 17:37:06898–PST F2 _ logger–INFO–HTTP 服务器启动！
2020-04-15 17:37:06，899–PST F2 _ logger–INFO–如果您希望终止服务器，请按 CTRL+C**

通过按 Ctrl+C 终止服务器，这将杀死 HTTP 和 p0f 实例。您应该也会看到类似的内容:

**2020-04-15 17:37:48，263–PST F2 _ logger–INFO–HTTP 服务器停止！
2020-04-15 17:37:48263–PST F2 _ logger–INFO–Killing p0f…
2020-04-15 17:37:48263–PST F2 _ logger–INFO–p0f killed！
2020-04-15 17:37:48，263–PST F2 _ logger–INFO–exiting…**

注意，设置一个指向你的服务器的 DNS 记录超出了 pstf^2 的范围，由你自己负责。

**有效载荷管理**

pstf^2 拥有在`server_config.yml`中定义的默认有效载荷，可以轻松定制。

**良性反应**

有两种模式，通过改变`YES`或`NO`的`rickroll_mode`变量进行切换。如果启用，这个安全工具将被重定向到 YouTube 上著名的电影《T4》的页面，否则它将提供一个在同一个 YAML 文件中定义的字符串。

**恶意回应**

默认情况下，将“恶意”响应设置为 EICAR 标准测试字符串。

[**Download**](https://github.com/G4lB1t/pstf2)