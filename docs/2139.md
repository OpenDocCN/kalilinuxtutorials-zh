# Kodex:隐私和安全工程工具包:发现、理解、假名化、匿名化、加密和安全地共享敏感和个人数据:作为代码的隐私和安全

> [https://kallinuxxtauthorities . com/code/](https://kalilinuxtutorials.com/kodex/)

[![](img//9eb0af1a6a9fb90d9167d743d6a9a2b2.png)](https://1.bp.blogspot.com/-R5sJMsi7C8U/YVVEvQwIBmI/AAAAAAAAK_Q/N8WBwiuOadUjtpxy2ySgyDrFgmf1DoiDwCLcBGAsYHQ/s1699/5%2B%25281%2529.png)

**Kodex(社区版–CE)**是一个用于**隐私和安全工程**的开源工具包。它可以帮助您在数据工程工作流程中自动执行数据安全和数据保护措施。它提供以下功能:

*   从文件、数据库或消息队列等各种来源读取数据项。
*   使用各种隐私和安全增强转换来保护这些数据项，如去标识、屏蔽、假名化、匿名化或加密。
*   将受保护的项目发送到不同的目的地。

借助 Kodex，您可以使用简单的声明性配置语言来描述您的数据保护和数据安全工作流:就像 DevOps 工具让您将基础架构描述为代码一样，Kodex 是一个**privacy ops**&**security ops**工具，让您将**隐私和安全措施描述为代码**。

Kodex 处理隐私的无聊和困难的方面，例如

*   **密钥管理** : Kodex 为您管理加密和假名化密钥(如果您愿意的话)。
*   **参数管理** : Kodex 跟踪每个数据项的处理方式，以便您能够证明数据工作流的合规性并创建审计跟踪。
*   **数据转换** : Kodex 采用现代加密和统计技术来保护您的数据。

**入门**

要从源代码下载并安装 Kodex，只需运行

**git 克隆 https://github.com/kiprotect/kodex
CD kiprotect
make
make 安装**

证明文件

CLI

命令行实用程序是开始使用 Kodex 分析和转换数据的最简单方法。

**蓝图**

蓝图是指定 Kodex 应该如何加载、分析、转换和写入数据的配置文件。

**动作**

动作对输入项目执行特定的操作，例如分析或转换它们。Kodex 对数据所做的一切都是用一个动作来描述的。

**Kodex 社区版(CE)**

要安装 Kodex 的社区版，只需运行

**git 克隆 https://github.com/kiprotect/kodex
CD kodex
make
make 安装**

就是这样！您现在可以使用`**kodex**` CLI 命令处理蓝图。

**Kodex 企业版(EE)**

要安装 Kodex 企业版(Kodex-EE)，首先从我们的门户网站下载`**kodex-ee**`。该二进制文件包含您开始所需的一切。值得注意的是，它提供了一个`**install**`命令，该命令(大部分)自动为不同的环境安装 Kodex-EE。例如，要创建一个包含所有 Kodex 组件和所需外部服务的 Docker compose 配置，只需运行

**码-ee 安装–方法坞站-复合
cd 坞站-复合
坞站-复合**

这应该给你一个功能齐全的测试系统，Kodex 前端运行在端口 4242 上。以下部分详细解释了如何让 Kodex-EE 以更持久的方式在您的基础设施上运行。

**部署选项**

如上所述，Kodex-EE 被部署为一组无状态的 Linux 服务，它们与外部数据库和系统进行交互。一个完整的部署包括至少一个**守护进程**和一个 **API** 实例。这两种服务都是无状态的，可以使用简单的设置文件进行配置。该 API 被设计用于处理 TLS 和负载平衡的反向代理之后(像 **nginx** 或 **caddy** 这样的服务器的示例配置是可用的)。

**要求**

Kodex-EE 需要几个外部服务才能运行:

*   一个 **PostgreSQL** 数据库(最好是 9.6 或更新版本)，Kodex-EE 用它来存储关于数据流、动作和参数的元数据。特定的 Kodex-EE 插件(例如 Klaro、Konsens)使用自己的 PostgreSQL 模式进行数据存储。出于稳定性和性能原因，建议为这些提供单独的 PostgreSQL 实例。
*   一个 **RabbitMQ** 服务器(最好是 3.8 或更高版本)，或者一个 **Kafka** 服务器(最好是 2.7 或更高版本)，Kodex-EE 在处理过程中使用它来存储中间数据项。
*   基于 SSO、SAML、OpenID-Connect 或 LDAP 的**认证服务，Kodex-EE 可以使用它来认证用户。该服务必须提供用户到组织以及这些组织中的角色的映射。**
*   一个 **Redis** 数据库(最好是版本 5.0 或更新版本)，Kodex-EE 使用它来存储 API 和数据处理指标以及速率限制所需的数据。
*   *可选的*，或者是可从 API 和守护程序节点访问的**持久目录/卷**，或者是具有 S3 兼容 API 的**“blob”存储服务**。Kodex-EE 使用这些来存储为某些后台任务生成的文件数据。

给定的最低服务版本是 Kodex-EE 测试和部署的基础，它也可能在旧版本上运行，尽管我们不能做出任何保证。使用这些服务的新版本时也是如此。

**PostgreSQL 数据库**

Kodex-EE 使用主数据库模式来存储元数据，如数据转换、源和目的地。对于常规使用，只生成少量的表条目，并且主数据库模式很少增长超过几 GB。特定的 Kodex-EE 插件(例如 Klaro 或 Konsens)使用二级数据库模式来存储数据结果，这些数据结果与处理的数据成比例增长。Kodex-EE 可以实施数据保留计划，并将删除旧数据，但所需的存储空间将取决于所处理的数据量。请注意，如果正在处理大量数据，性能也可能会下降。所有 Kodex-EE 数据模式的设计都是为了处理数十亿行数据，只要为数据库提供了足够的硬件，就不会出现重大问题。

**重定向数据库**

Kodex-EE 使用 Redis 收集指标并在处理过程中保存内部状态(例如匿名化)。使用分层时间跨度(小时、天、周、月、年)生成指标，并且各个数据项会自动过期。根据数据处理的类型和处理的项目数量，内部状态存储要求会有所不同。

**消息队列(RabbitMQ 或 Kafka)**

Kodex-EE 将处理过的数据存储在消息队列中，用于内部处理和缓冲。存储在这些队列中的数据量取决于许多因素，特别是传入数据项的数量、守护程序节点的数量以及数据源和目标的读/写能力。当无法写入内部队列时，Kodex-EE 会自动施加背压。

**守护进程& API 需求**

Kodex EE 可以在像嵌入式系统或 SoC 这样资源最少的系统上运行。

**操作系统**

Kodex-EE 作为静态编译的 X64/AMD64 二进制文件提供，与所有主流 Linux 发行版兼容。在 Windows，MacOS 和 OpenBSD 上运行 Kodex-EE 应该是可能的，但目前尚未测试和不支持。

**内存**

我们建议为 **API** 和**守护进程**提供至少 512 MB 的可用内存。实际内存使用情况可能会因工作负载而异，但 Kodex EE 会尝试自动限制数据处理，以免耗尽所有可用内存。

**CPU**

守护程序和 API 在并行线程中同时处理数据，因此它们可以有效地利用多个 CPU 内核/处理线程。

**存储**

除了上面提到的特定于任务的存储，守护进程和 API 都不需要持久的磁盘数据存储。

**联网**

Kodex-EE 需要连接到数据源和目的地，以便读取或写入数据。处理速度将受到可用网络带宽的限制。

**操作**

以下部分描述了 Kodex-EE 的操作相关方面。

**指标**

Kodex-EE 收集通过 REST API 公开的各种指标，并支持 Prometheus 的检测。

**测井**

Kodex-EE 有一个内部的、基于级别的日志记录系统，它与 **syslog** 兼容。

**命令行界面(CLI)**

Kodex 命令行界面(CLI)是开始隐私和安全工程的最简单方法。它使您能够在结构化数据上运行广泛的隐私和安全性增强转换以及分析。

**安装 Kodex CLI**

首先，您需要下载或构建 Kodex CLI 工具。您可以在我们的网站上下载各种平台的预构建二进制文件。或者，您可以按照 Github 页面上的说明从源代码构建该工具。

**入门**

默认情况下，我们使用所谓的**蓝图**来控制 CLI 工具。蓝图是一个配置文件(或它们的集合)，描述 Kodex 应该如何读取、分析、转换和写入结构化数据。

要运行蓝图，只需执行`**kodex run [blueprint name]**`。Kodex 附带了一个免费的、公开的范例蓝图库，可以帮助我们开始。我们也可以通过命令行下载并安装它们:

**kodex 蓝图下载**

这将下载我们的公共蓝图存储库，并将其存储在本地目录中(默认为`~/.kodex/blueprints`)。然后，您可以通过简单地指定相对于蓝图目录的路径来运行任何蓝图。因此，让我们运行一个简单的示例，展示 Kodex 如何假名化不同的数据类型:

**kodex run pseu**d**onymization/examples/data-types/假名化**

这将从蓝图文件(`pseudonymize.yml`)加载配置。这个文件指定了应该从哪里读取数据(在本例中是一个 JSON 文件)、应该如何转换数据(在本例中使用假名)以及结果输出数据应该发送到哪里(也是一个 JSON 文件)。

**input . JSON 文件中我们要假名的项目。
{
【姓名】:“考试”，
【日期】:“2020-06-04”，
【IP】:“42 . 34 . 122 . 112/32”，
【计数】:4354
}
{
【姓名】:“另考”，
【日期】:“2019-07-02”，**
**【IP】**

我们选择的示例蓝图将从与蓝图位于同一目录的`**input.json**`文件中读取数据项，使用不同的适用假名化方法假名化每个项的所有属性，并将假名化的数据写入当前目录中的 JSON 文件(`**pseudonymized.json**`)。下面是输出的样子:

**{
" _ kip ":" 278 ba 5 f 7 db 26 ca 661 B4 e 64 B1 eb6 ab 3d 4 e 7 D1 aa 15 e 55155 B3 a1 f 7626424 f 679 c "，
"计数":7643，
"日期":" 2021-09-11 "，
"ip": "150.39.196.226/32 "，
"名称" "**

如您所见，Kodex 对每个数据项中的每个属性都使用了假名，并且还为数据项添加了一个新属性`**_kip**`。该属性的值是指包含用于转换数据的加密密钥的参数集。实际的密钥存储在所谓的参数存储中。如果您不希望这样，您也可以自己管理密钥:同一目录中的`**pseudonymize-with-key**`蓝图首先要求您输入一个密钥，然后使用该密钥为各个假名化操作派生出更多的加密密钥。关键&参数管理本身是一个复杂的话题，现在请放心，Kodex 会为您处理这些混乱的细节。

**depseudonnaming 数据**

在某些时候，您可能真的想再次取消数据的命名。Kodex 提供了一个`undo`动作，可以应用于可逆转换，如上面的加密假名化，从而简化了这一过程。因此，为了将上面的数据去命名，我们可以简单地运行一个包含这样一个`undo`动作的蓝图:

**kodex 运行假名化/实例/数据类型/depseudonymize**

它将打印 depseudonymized 数据(应该与输入数据完全匹配)。如果您自己通过使用`**pseudonymize-with-key**`提供了一个假名化密钥，那么您可以运行`**depseudonymize-with-key**`蓝图，它会要求您输入假名化密钥。那不是很容易吗？

**动作**

动作是 Kodex 转换或分析数据的方式。动作可以单独调用，也可以按顺序调用，其中每个动作都将接收前一个动作的结果。以下部分描述了 Kodex 当前支持的不同操作类型。

**通用验证&转换**

通常，数据是复杂的和分层的，很难对其应用简单的转换。对于这种情况，Kodex 支持一般基于表单的数据验证和转换。这使您能够轻松地解析、验证和转换复杂的分层数据，如 JSON 文档。您可以在[表单操作文档](https://heykodex.com/docs/actions/form-action)中了解更多关于此类转换的信息。

**假名化**

假名化产生的数据不再直接归属于某个特定的个人。使用假名数据降低了个人数据处理的风险，并减少了数据丢失或数据被盗的影响。它可以应用于直接或间接标识符，以及广泛的结构化数据类型，如数字、日期、名称或 IP 地址。一些假名处理方法基于可逆加密，这使得在已知密钥的情况下再次对数据进行去假名处理成为可能。其他方法如散列法是不可逆的。

**加密**

加密产生的数据在统计上无法与随机噪声区分开来，并且只能用秘密加密密钥的知识来解密。Kodex 实现了标准的对称和非对称加密技术。

请注意，当给定相同的输入数据和加密密钥时，我们将产生相同密文的加密方法视为假名化方法，因为产生的数据不(故意)符合加密方法的现代安全标准。因此，在这种方法下，在没有随机初始化向量(IV)的情况下操作的格式保持加密方法也被认为是假名化方法。

**匿名化**

匿名化操作使用统计技术来产生数据，从这些数据中不可能识别任何特定的个人或推断关于这些个人的任何重要信息。Kodex 依靠随机化和聚合作为匿名机制，并产生符合“差分隐私”等现代匿名标准的匿名数据。

**发现**

发现操作使您能够检测结构化和非结构化数据项中不同类型的个人或敏感信息。

**身份识别&身份管理**

身份识别和身份管理操作使您能够基于各种直接或间接的标识符识别个人，并将一个永久的假名 ID 与每个个人相关联。这允许您例如将来自不同来源的数据项归属于单个个人，并使用该个人的假名 ID 来例如产生匿名或假名数据，或者为了给定的数据处理目的验证该个人的同意。

**同意管理**

同意管理操作使您能够验证给定的个人是否同意特定的数据处理目的。与身份识别和身份管理操作一起，它们使您能够构建合规的数据处理工作流，例如，压制来自个人的数据，这些个人尚未出于特定处理目的给予或撤回同意。

**审计日志**

审计日志记录操作使您能够跟踪从个人到整个数据处理基础结构的数据流。它们产生关于属于特定个人的数据如何被处理以及它被发送到哪里的假名、可搜索的信息，允许你例如检索、修改或删除这些数据。

**表单动作**

`**form**`动作实现了我们的开源表单验证&转换库，使您能够解析、验证和转换复杂的分层数据。

**入门**

一个**表单**由多个**字段**组成。每个字段可以定义一个或多个**验证器**，它们可以验证和转换字段的内容。如果表单验证成功，该操作将返回经过验证的字段。否则，将会抛出一个错误。下面是一个表单操作规范示例:

类型:**表单
配置:
字段:
–名称:日期
验证器:
–类型:is string
–类型:IsTime
配置:
格式:RFC 3339
–名称:计数
验证器:
–类型:IsInteger
配置:
has min:true
min:0
has max:true
max:1000**

此操作将确保每个项目都有一个包含 RFC-3339 格式数据字符串的`**date**`字段和一个包含 0 到 1000 之间的整数值的`count`字段。还有许多其他可用的验证器类型，下面是完整的列表:

*   **can behind**:只确保字段存在，但不对其执行任何其他验证。
*   **IsBoolean** :确保该字段包含布尔值，即`**true**`或**T1。**
*   **IsBytes** :确保该字段包含一个给定`**encoding**`的字节数组，如`**hex**`、`**base64**`或`**base64-url**`编码数据。
*   **IsFloat** :确保字段包含浮点值。可选地，如果`**hasMin**`或`**hasMax**`是`**true**`，则`**min**`或`**max**`配置选项定义浮点值的范围。
*   **IsHex** :确保字段包含一个十六进制值。如果`**convert**`为`**true**`，该值将被转换为一个字节数组。
*   **IsIn** :确保字段包含指定的`**choices**`之一。
*   **IsInteger** :确保该字段包含整数值。可选地，如果`**hasMin**`或`**hasMax**`是`**true**`，则`**min**`或`**max**`配置选项定义整数值的范围。
*   **IsList** :确保字段包含值列表。可选地，列表`**validators**`将被应用于每个列表元素。
*   **IsNotIn** :类似 **IsIn** ，但确保给定 **`choices`中该字段的值为**而非**。**
*   **IsOptional** :如果字段未定义，将跳过其他验证器，使其成为可选的。
*   **IsString** :确保字段包含一个字符串值。可选地，`**minLength**`和`**maxLength**`指定字符串的最小和最大长度。
*   **IsStringList** :确保字段包含字符串列表。可选地，列表`**validators**`将被应用于每个列表元素。
*   **IsStringMap** :确保字段包含基于字符串的哈希映射/字典。可选地，可以指定一个用于验证该值的`**form**`。
*   **IsTime** :确保字段包含给定`**format**`中的日期时间对象，可以是`**rfc3339**`、`**rfc3339-date**`、`**unix**`、`**unix-nano**`或`**unix-milli**`。如果`**raw**`为真，字符串将不会被转换成`**Time**`对象。如果`**toUTC**`为真，那么产生的`Time`对象将被转换为 **`UTC`。**
*   **isuid**:确保该字段包含一个 UUID 值。
*   **MatchesRegex** :确保字段匹配给定的正则表达式。假设该字段包含一个字符串值，应该在使用`**IsString**`验证器之前对其进行验证。
*   **或**:确保该字段包含由一个列表`**options**`指定的几个可能值中的一个，该列表又包含一个验证器列表。将在成功验证值的第一个选项处停止。
*   **开关**:根据`**cases**`字符串映射中定义的验证器列表来验证字段，其中选择的案例取决于另一个字段的值，该字段的名称由`**key**`给出。

**表单内的动作**

此外，表单机制还通过`IsAction`验证器支持所有其他动作，它将动作规范作为配置。示例验证程序:

**类型:IsAction
配置:
类型:假名
配置:
方法:梅伦格**

这将使用`**merengue**`方法对值进行假名化。嵌入动作的参数由表单动作自动管理。

**蓝图**

蓝图是指定 Kodex 应该如何读取、分析转换和写入数据的配置。

隐私和安全工程很复杂:在典型的场景中，我们可能希望从各种来源(例如数据库、文件或 API)读取数据，并出于不同的目的(例如分析或异常检测)对其进行处理，这通常需要不同的转换。我们还可能希望将数据发送到各种目的地(例如数据库或消息队列)。最后，随着数据的产生，我们可能希望不断地完成所有这些工作。

为了尽可能简单，我们实现了一个基于 YAML 文件的声明性和表达性的配置语言。像 Kubernetes 或 Ansible 这样的其他系统已经表明，YAML 文件的集合可以成为配置管理的强大工具。此外，文件易于使用，并且可以像任何其他配置文件一样进行版本控制。

**蓝图基础知识**

蓝图的基本结构。这个例子将从 SQL 数据库中读取数据，对其进行假名处理，并将假名处理的数据转发给 HTTP API。
动作:#我们希望应用于数据项的不同动作

*   **name:假名-name
    type:假名
    ……
    sources:# sources 我们要从**加载数据项
*   **名称:production-db
    类型:SQL
    ……
    目的地:#我们要将数据项发送到的目的地**
*   **name:audit-API
    type:http
    ……
    streams:#我们要处理的数据项的流**
*   **name: default description: |在将传入的数据发送到 audit API 之前对其使用假名。sources: #该流的数据项的来源**
    *   **生产数据库
        配置:#此流的配置**
    *   **名称:默认动作:#该配置中的动作**
        *   **假名
            目的地:#这些物品要发往的目的地**
        *   **名称:audit-api**

一个蓝图本质上包含至少四个不同的部分:动作、源、目的地和流。每个流引用一个或多个源，并包含一个或多个流配置。每个流配置引用一个或多个动作以及一个或多个目的地。这些原语一起告诉 Kodex 数据应该如何流经它，以及应该如何分析和转换它。

**运行蓝图**

您可以使用`**run**`命令运行给定的蓝图:

**kodex 运行【蓝图名称】**

如果您省略了`[**blueprint name]**`，Kodex 将在当前目录中查找一个名为`**.blueprint.yml**`的文件来运行。否则，Kodex 将首先检查您是否输入了一个文件位置，如果是，就从那里加载蓝图。否则，Kodex 将遍历它所有的蓝图目录(默认为`**~/.kodex/blueprints**`)并尝试找到你指定的蓝图。例如，如果我们跑

**kodex 运行假名化/实例/数据类型/假名化**

Kodex 将尝试在任何给定的蓝图路径的子文件夹`**pseudonymization/examples/data-types**`中查找名为`**pseudonymize.yml**`的蓝图。有时您可能安装了不同版本的蓝图。默认情况下，Kodex 会加载它能找到的最新版本。如果您不希望这样，您可以使用`**--version**`标志指定一个版本:

**kodex 运行我的蓝图–版本 0.4.1**

版本号遵循语义版本规范(2.0)。

**蓝图库**

Kodex 允许你从所谓的仓库下载并安装蓝图。例如，要获得我们的官方蓝图库，只需运行

这将下载我们的蓝图存储库的主分支的最新快照，并将其安装到本地目录中。如果您想从不同的 URL 下载蓝图，只需提供:

**kodex 蓝图下载 https://my.blueprints/repo.zip**

Kodex 将在 ZIP 存档中寻找一个带有`**.blueprints.yml**`文件的目录，并将该目录提取到主蓝图路径。当然，您也可以创建自己的本地蓝图存储库，只需确保将它们放在蓝图路径的子文件夹中，并创建一个包含以下内容的`**.blueprints.yml**`文件:

**包:[您的包名] #例如我的蓝图
版本:[您的版本] #例如 1.5.2**

[**Download**](https://github.com/kiprotect/kodex)