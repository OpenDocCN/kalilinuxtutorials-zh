# 哗变模糊器:网络模糊器通过变异模糊器重放 PCAPs

> 原文：<https://kalilinuxtutorials.com/mutiny-fuzzer/>

哗变模糊器框架是一个网络模糊器，通过变异模糊器重放 PCAPs 来运行。目标是以牺牲彻底性为代价，尽快开始网络模糊化。

哗变的一般工作流程是获取合法流量的样本，如浏览器请求，并将其送入 prep 脚本以生成一个. fuzzer 文件。

然后，兵变可以用这个运行。fuzzer 文件生成针对目标主机的流量，改变用户想要的任何数据包。

有一些扩展允许改变哗变的行为方式，包括根据输入/输出改变消息，改变哗变响应网络错误的方式，以及在一个单独的线程中监视目标。

兵变使用[雷达姆萨](https://github.com/aoh/radamsa)进行变异。

[Decept 代理](https://github.com/Cisco-Talos/Decept)是一个多用途网络代理，可以将明文或 TLS TCP/UDP/域套接字连接的流量转发到明文或 TLS TCP/UDP/域套接字连接，以及其他功能。

它是兵变的好伙伴，因为它可以同时产生。fuzzer 文件直接，特别有帮助时，模糊 TLS 连接，并允许哗变与 TLS 主机通信。

sample_apps 给出了使用 fuzzer 可以完成的一些事情的基本概念，并提供了一些不同的应用程序/客户端进行测试。

**也读作-[flight sim:生成恶意网络流量的实用程序&评估控件](https://kalilinuxtutorials.com/flightsim-malicious-network-traffic/)**

**设置**

确保安装了 python 和 scapy。

Untar Radamsa 和`make`(您不必进行安装，除非您希望它在/usr/bin 中——它将使用本地 Radamsa ),如果您更改了 Radamsa 的路径，请更新`mutiny.py`。

**基本用法**

将 pcap 保存到文件夹中。在`<XYZ>.pcap`上运行`mutiny_prep.py`(也可以选择传递定制处理器的目录，如果有的话，下面会详细介绍)。回答问题，在与 pcap 相同的文件夹中以一个`<XYZ>.fuzzer`文件结束。

运行`mutiny.py <XYZ>.fuzzer <targetIP>`这将开始起毛。日志将保存在目录`<XYZ>_logs/<time_of_session>/<seed_number>`下的同一文件夹中

**更详细的用法**

**。模糊文件**

的。fuzzer 文件是人类可读的，并带有注释。它们允许在每个模糊化文件的基础上更改各种选项，包括哪些消息或消息部分被模糊化。

**消息格式**

在. fuzzer 文件中是消息内容。这些只是以“入站”或“出站”开头的行，表示消息的方向。它们是 Python 字符串格式，使用' \xYY '表示不可打印的字符。这些是由'哗变 _ 准备. py '和 Decept 自动生成的，但有时需要手动修改。

**消息格式化-手动编辑**

如果消息在“outbound”后有“fuzz”关键字，这表明它将通过 Radamsa 进行模糊处理。给定的消息可以有行延续，只需在新的一行上用引号括起更多的消息数据。在这种情况下，第二行将与第一行合并。

或者，可以使用“sub”关键字来表示子组件。这允许指定消息的一个单独的组成部分，以便只模糊某些部分，并且在消息处理器中更方便。

以下是任意一组消息数据的示例:

**出站'说'
'嗨'
子模糊'和模糊'
'这个'
子'但不是这个\xde\xad\xbe\xef'
入站'这是服务器的'
'预期响应'**

这将导致兵变传播`say hi and fuzz this but not this(0xdeadbeef)`。`0xdeadbeef`将作为 4 个十六进制字节传输。`and fuzz this`将通过雷达天线进行模糊处理，但`say hi`和 `but not this(0xdeadbeef)`将被单独留下。

由于“入站”线路的原因，兵变将在发送上述单一消息后等待服务器的响应。服务器的预期响应是`this is the server's expected response`。

除了查看服务器实际发送的内容是否与该字符串匹配之外，哗变不会对这些数据做太多处理。如果发生崩溃，哗变将记录服务器的预期输出和服务器的实际回复。

**定制**

包含消息处理器、监视器和异常处理器的基类。这些文件中的任何一个都可以复制到。中指定为“processor_dir”的单独子文件夹中。模糊文件。

这三个类允许存储服务器响应和更改传出消息，在单独的线程上监视目标，以及更改 manturit 处理异常的方式。

**定制–消息处理器**

消息处理器定义了在模糊运行期间调用的各种回调。在这些回调中，任何 Python 代码都可以运行。有趣的是，这些主要用于三个方面。

最常见的情况是服务器发送需要添加到未来出站消息中的令牌。例如，如果哗变的第一条消息登录，并且服务器用一个会话 ID 响应，那么可以使用`postReceiveProcess()`回调来存储这个会话 ID。然后，在`preSendProcess()`中，可以用该会话 ID 来修正输出数据。这方面的一个例子是在`sample_apps/session_server`。

消息处理器的另一个常见用途是限制或改变模糊的消息。例如，如果服务器总是丢弃大于 1000 字节的消息，则可能不值得发送任何大消息。preSendProcess()可用于在模糊化之后发送之前缩短消息，或者引发异常。

引发异常会引出消息处理器的最终使用方式。在回调中，可以引发任何在`mutiny_classes/mutiny_exceptions.py`中定义的自定义异常。有几个例外，所有评论，这将导致各种行为从哗变。这些通常包括记录、重试或中止当前运行。

**定制–监控**

监视器有一个`monitorTarget()`功能，在独立于主哗变引信的线程上运行。目的是允许实现一个长时间运行的进程，该进程可以以某种方式监视主机。这可以是 Python 中可以完成的任何事情，比如与运行在目标上的监视器守护进程通信、读取一个长文件，甚至只是重复 ping 主机，这取决于 fuzzing 会话的需求。

如果监视器检测到崩溃，它可以随时调用`signalMain()`。这将向主哗变线程发出发生崩溃的信号，并记录该崩溃。这个函数通常应该在无限循环中运行，因为返回将导致线程终止，并且不会重新启动。

**定制–异常处理器**

异常处理器确定在模糊会话期间，哗变应该对给定的异常做什么。从最普遍的意义上来说，`processException()`函数将尽可能地把 Python 和 OS 级别的异常转化为哗变错误处理动作。

例如，如果 mutate 得到“连接被拒绝”，默认的响应是假设目标服务器已经不可恢复地死亡，所以 mutate 将记录以前的运行和停止。这在大多数情况下是正确的，但是这种行为可以根据需要更改为`mutiny_classes/mutiny_exceptions.py`中的任何异常，允许定制崩溃检测和错误纠正。

信用:詹姆士·斯帕达罗&莉莉斯·怀亚特

[**Download**](https://github.com/cisco-talos/mutiny-fuzzer)